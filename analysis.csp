package analysis

import analysis_impl

function __impl_make_dataframe(header, data)
    var df = new dataframe
    df.header_map = new hash_map
    foreach idx in range(header.size) do df.header_map.insert(header.at(idx), idx)
    df.header = header
    df.data := data
    return move(df)
end

function __impl_make_dataframe_groupby(header, groups, data)
    var df = new dataframe
    df.header_map = new hash_map
    foreach idx in range(header.size) do df.header_map.insert(header.at(idx), idx)
    df.header = header
    df.data := data
    return move(df)
end

class selection
    var cols = new array
    var raw_data = null
    var headers = null
    function filter(cond)
        return analysis_impl.filter(raw_data, cols, cond)
    end
    function __groupby_impl(iteration, data, idx)
        var result = analysis_impl.groupby(data, cols.at(idx))
        if iteration > 0
            foreach it in result do it.second = __groupby_impl(iteration - 1, it.second, idx + 1)
        end
        return move(result)
    end
    function groupby()
        var data = __groupby_impl(cols.size - 1, raw_data, 0)
        var groups = new hash_map
        foreach idx in cols.size do groups.insert(name, header.at(cols.at(idx)))
        return __impl_make_dataframe_groupby(header, groups, data)
    end
    function aggregate(...args)
        
    end
end

class dataframe
    var header_map = null
    var header = null
    var data = null
    function columns(...args)
        var sel = new selection
        sel.data = &data
        if args.empty()
            foreach it in range(header.size) do sel.cols.push_back(it)
            sel.header = header
        else
            sel.header = new array
            foreach it in args
                link idx = header_map.at(it)
                sel.header[idx] = it
                sel.cols.push_back(idx)
            end
        end
        return move(sel)
    end
    function find_broken_lines()
        var lines = new array
        foreach i in range(data.size)
            if data.at(i).size != header.size
                lines.push_back(i + 2)
            end
        end
        return move(lines)
    end
    function to_csv(file)
        var csv_data = data
        csv_data.push_front(header)
        analysis_impl.write_csv(csv_data, file)
    end
end

function __impl_unstack_group_impl(group, target)
    if typeid group == typeid array
        foreach it in group do target.push_back(it)
    else
        foreach it in group do __impl_unstack_group_impl(it.second, target)
    end 
end

function __impl_unstack_group(group)
    var flat_data = new array
    __impl_unstack_group_impl(group, flat_data)
    return move(flat_data)
end

function __get_group_impl(iteration, group, target, idx)
    if iteration == idx
        target.push_back(group)
    else
        foreach it in group do __get_group_impl(iteration + 1, it.second, idx)
    end
end

class dataframe_groupby
    var header_map = null
    var header = null
    var groups = null
    var data = null
    function get_group(key)
        var flat_data = new array
        var idx = groups.at(key)
        __get_group_impl(0, data, flat_data, idx)
        return __impl_unstack_group(flat_data)
    end
    function unstack()
        return __impl_unstack_group(data)
    end
    function aggregate(...args)

    end
end

function read_csv(path)
    var data = analysis_impl.read_csv(path)
    if data != null
        link header = data.front
        data.pop_front()
        return __impl_make_dataframe(header, data)
    end
end