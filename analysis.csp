package analysis

import analysis_impl as impl

function __impl_make_dataframe(header, data)
    var df = new dataframe
    df.header_map = new hash_map
    foreach idx in range(header.size) do df.header_map.insert(header.at(idx), idx)
    df.header = header
    df.data = data
    return move(df)
end

function __impl_make_dataframe_groupby(header, groups, data)
    var df = new dataframe_groupby
    df.header_map = new hash_map
    foreach idx in range(header.size) do df.header_map.insert(header.at(idx), idx)
    df.header = header
    df.groups = groups
    df.data = data
    return move(df)
end

class selection
    var cols = new array
    var raw_data = null
    var header = null
    function filter(cond)
        return __impl_make_dataframe(header, impl.filter(*raw_data, cols, cond))
    end
    function __groupby_impl(iteration, data, idx)
        var result = idx == 0 ? impl.groupby(data, cols.at(idx)) : impl.groupby_group(*raw_data, data, cols.at(idx))
        if iteration > 0
            foreach it in result do it.second = __groupby_impl(iteration - 1, it.second, idx + 1)
        end
        return move(result)
    end
    function groupby()
        return __impl_make_dataframe_groupby(header, __groupby_impl(cols.size - 1, *raw_data, 0), raw_data)
    end
    function aggregate(...args)
        
    end
end

class dataframe
    var header_map = null
    var header = null
    var data = null
    function columns(...args)
        var sel = new selection
        sel.raw_data = &data
        sel.header = header
        if args.empty()
            foreach it in range(header.size) do sel.cols.push_back(it)
        else
            foreach it in args do sel.cols.push_back(header_map.at(it))
        end
        return move(sel)
    end
    function select(...args)
        var cols = new array
        foreach it in args do cols.push_back(header_map.at(it))
        return __impl_make_dataframe(args, impl.select(data, cols))
    end
    function find_broken_lines()
        var lines = new array
        foreach i in range(data.size)
            if data.at(i).size != header.size
                lines.push_back(i + 2)
            end
        end
        return move(lines)
    end
    function to_csv(file)
        var csv_data = data
        csv_data.push_front(header)
        impl.write_csv(csv_data, file)
    end
end

function __impl_unstack_group_impl(group, target)
    if typeid group == typeid array
        foreach it in group do target.push_back(it)
    else
        foreach it in group do __impl_unstack_group_impl(it.second, target)
    end 
end

function __impl_unstack_group(group, data)
    var lines = new array
    __impl_unstack_group_impl(group, lines)
    var result = new array
    foreach idx in lines do result.push_back(data.at(idx))
    return move(result)
end

function __get_group_impl(group, key, target)
    if typeid group != typeid hash_map
        throw runtime.exception("Group not exist!")
    end
    if group.exist(key)
        target.push_back(group.at(key))
    else
        foreach it in group do __get_group_impl(it.second, key, target)
    end
end

class dataframe_groupby
    var header_map = null
    var header = null
    var groups = null
    var data = null
    function get_group(key)
        var lines = new array
        __get_group_impl(groups, key, lines)
        return __impl_make_dataframe(header, __impl_unstack_group(lines, *data))
    end
    function unstack()
        return __impl_make_dataframe(header, __impl_unstack_group(groups, *data))
    end
    function aggregate(...args)

    end
end

function read_csv(path)
    var data = impl.read_csv(path)
    if data != null
        link header = data.front
        data.pop_front()
        return __impl_make_dataframe(header, move(data))
    end
end